# 利用用户行为数据

实现个性化推荐的最理想情况是用户能在注册的时候主动告诉我们他喜欢什么，但这种方法有３个缺点：

- 首先，现在的自然语言理解技术很难理解用户用来描述兴趣的自然语言；
- 其次，用户的兴趣是不断变化的，但用户不会不停地更新兴趣描述；
- 最后，很多时候用户并不知道自己喜欢什么，或者很难用语言描述自己喜欢什么。

基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。

## 1. 用户行为数据简介

**用户行为数据**在网站上**最简单的存在形式就是日志**。网站在运行过程中都产生大量原始日志（raw log），并将其存储在文件系统中。**很多互联网业务会把多种原始日志按照用户行为汇总成会话日志（session log），其中每个 会话表示一次用户行为和对应的服务。**比如，在搜索引擎和搜索广告系统中，服务会为每次查询生成一个展示日志（impression log），其中记录了查询和返回结果。如果用户点击了某个结果，这个点击信息会被服务器截获并存储在点击日志（click log）中。一个并行程序会周期性地归并展示日志和点击日志，得到的会话日志中每个消息是一个用户提交的查询、得到的结果以及点击。类似地，推荐系统和电子商务网站也会汇总原始日志生成描述用户行为的会话日志。会话日志通常存储在分布式数据仓库中，如支持离线分析的 Hadoop Hive和支持在线分析的Google Dremel。这些日志记录了用户的各种行为，如在电子商务网站中这些行为主要包括网页浏览、购买、点击、评分和评论等。

​	用户行为在个性化推荐系统中一般分两种——**显性反馈行为（explicit feedback）**和**隐性反馈行为（implicit feedback）**。

- 显性反馈行为包括用户明确表示对物品喜好的行为。

- 隐性反馈行为指的是那些不能明确反应用户喜好的行为。最具代表性的隐性反馈行为就是页面浏览行为。

![1545285361490](C:\Users\dby_freedom\AppData\Roaming\Typora\typora-user-images\1545285361490.png)

互联网中的用户行为有很多种，比如浏览网页、购买商品、评论、评分等。要用一个统一的方式表示所有这些行为是比较困难的。表2-3给出了一种表示方式，它将一个用户行为表示为6部
分，即**产生行为的用户和行为的对象、行为的种类、产生行为的上下文、行为的内容和权重。**

![1545285516592](C:\Users\dby_freedom\AppData\Roaming\Typora\typora-user-images\1545285516592.png)

当然，在很多时候我们并不使用统一结构表示所有行为，而是针对不同的行为给出不同表示。而且，有些时候可能会忽略一些信息（比如上下文）。当然，有些信息是不能忽略的，比如产生
行为的用户和行为的对象就是所有行为都必须包含的。一般来说，不同的数据集包含不同的行为，目前比较有代表性的数据集有下面几个。



- 无上下文信息的隐性反馈数据集 每一条行为记录仅仅包含用户ID和物品ID。Book-Crossing①就是这种类型的数据集。
- 无上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品的评分。
- 有上下文信息的隐性反馈数据集 每一条记录包含用户ID、物品ID和用户对物品产生行为的时间戳。Lastfm数据集就是这种类型的数据集。
- 有上下文信息的显性反馈数据集 每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。Netflix Prize提供的就是这种类型的数据集。

## 2. 用户行为分析

### 2.1 用户活跃度和物品流行度的分布

很多关于互联网数据的研究发现，互联网上的很多数据分布都满足一种称为Power Law③的分布，这个分布在互联网领域也称**长尾分布**。
$$
f(x) = \alpha x^k
$$
长尾分布其实很早就被统计学家注意到了。1932年，哈佛大学的语言学家Zipf在研究英文单词的词频时发现，如果将单词出现的频率按照由高到低排列，则每个单词出现的频率和它在热门排行榜中排名的常数次幂成反比。这个现象表明，在英文中大部分词的
词频其实很低，只有很少的词被经常使用。
很多研究人员发现，用户行为数据也蕴含着这种规律。令$f_u(k)$为对k个物品产生过行为的用户数，令$f_i(k)$为被k个用户产生过行为的物品数。那么，$f_u(k)$和$f_i(k)$都满足长尾分布。也就是说：
$$
f_i (k) = \alpha_i k^{\beta_i}
$$

$$
f_u (k) = \alpha_u k ^{\beta_u}
$$

### 2.2 用户活跃度和物品流行度的关系

一般认为，新用户倾向于浏览热门的物品，因为他
们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品。图2-5展示了MovieLens数据集中用户活跃度和物品流行度之间的关系，其中横坐标是用户活跃度，纵坐标是具有某个活跃度的所有用户评过分的物品的平均流行度。如图2-5所示，图中曲线呈明显下降的趋势，这表明**用户越活跃，越倾向于浏览冷门的物品。**

![1545286521260](C:\Users\dby_freedom\AppData\Roaming\Typora\typora-user-images\1545286521260.png)



仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法。学术界对协同过滤算法进行了深入研究，提出了很多方法，比如基于邻域的方法（neighborhood-based）、隐语义模型（latent factor model）、基于图的随机游走算法（random walk on graph）等。在这些方法中，最著名的、**在业界得到最广泛应用的算法是基于邻域的方法**，而基于邻域的方法主要包含下面两种算法。

- **基于用户的协同过滤算法** 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。
- **基于物品的协同过滤算法** 这种算法给用户推荐和他之前喜欢的物品相似的物品。

### 2.3 实验设计和算法评测

#### 2.3.1 数据集
本章采用GroupLens提供的MovieLens数据集①介绍和评测各种算法。 该数据集包含6000多用户对4000多部电影的100万条
评分。该数据集是一个评分数据集，用户可以给电影评5个不同等级的分数（1～5分）。本章着重究隐反馈数据集中的TopN推荐问题，因此忽略了数据集中的评分记录。也就是说，**TopN推荐的任务是预测用户会不会对某部电影评分，而不是预测用户在准备对某部电影评分的前提下会给电影评多少分。**

#### 2.3.3 评测指标
对用户u推荐N个物品（记为R(u)），令用户u在测试集上喜欢的物品集合为T(u)，然后可以**通过准确率/召回率评测推荐算法的精度**：
$$
Recall = \frac{\sum_n |R(u) \cap T(u)|}{\sum_u |T(u)|}
$$

$$
Precision = \frac{\sum_n |R(u) \cap T(u)|}{\sum_u |R(u)|}
$$


> 公式中R是Recommendation缩写；T是Testset缩写；

- **召回率描述有多少比例的用户—物品评分记录包含在最终的推荐列表中**

- **准确率描述最终的推荐列表中有多少比例是发生过的用户—物品评分记录。**

```
def Recall(train, test, N):
	hit = 0
	all = 0
	for user in train.keys():
		tu = test[user]
		rank = GetRecommendation(user, N)
		for item, pui in rank:
			if item in tu:
				hit += 1
		all += len(tu)
	return hit / (all * 1.0)
	
def Precision(train, test, N):
	hit = 0
	all = 0
	for user in train.keys():
		tu = test[user]
		rank = GetRecommendation(user, N)
		for item, pui in rank:
			if item in tu:
				hit += 1
		all += N
	return hit / (all * 1.0)
```



除了评测推荐算法的精度，本章还计算了算法的**覆盖率**，覆盖率反映了推荐算法发掘长尾的能力，覆盖率越高，说明推荐算法越能够将长尾中的物品推荐给用户。这里，我们采用最简单的覆盖率定义：
$$
Converage = \frac{|\cup_{u \in U} R(u)|}{|I|}
$$

```
def Coverage(train, test, N):
	recommend_items = set()
	all_items = set()
	for user in train.keys():
		for item in train[user].keys():
			all_items.add(item)
		rank = GetRecommendation(user, N)
		for item, pui in rank:
			recommend_items.add(item)
	return len(recommend_items) / (len(all_items) * 1.0)
```



最后，我们还需要评测**推荐的新颖度**，这里用推荐列表中物品的平均流行度度量推荐结果的新颖度。如果推荐出的物品都很热门，说明推荐的新颖度较低，否则说明推荐结果比较新颖。



```
def Popularity(train, test, N):
	item_popularity = dict()
	for user, items in train.items():
		for item in items.keys()
			if item not in item_popularity:
				item_popularity[item] = 0
			item_popularity[item] += 1
	ret = 0
	n = 0
	for user in train.keys():
		rank = GetRecommendation(user, N)
		for item, pui in rank:
			ret += math.log(1 + item_popularity[item])
			n += 1
	ret /= n * 1.0
	return ret
```

这里，在计算平均流行度时对每个物品的流行度取对数，这是因为物品的流行度分布满足长尾分布，在取对数后，流行度的平均值更加稳定。



